// Code generated by protoc-gen-go. DO NOT EDIT.
// source: Header.proto

package hermes

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Header_Type int32

const (
	Header_Network Header_Type = 0
	Header_File    Header_Type = 1
)

var Header_Type_name = map[int32]string{
	0: "Network",
	1: "File",
}
var Header_Type_value = map[string]int32{
	"Network": 0,
	"File":    1,
}

func (x Header_Type) String() string {
	return proto.EnumName(Header_Type_name, int32(x))
}
func (Header_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor2, []int{1, 0} }

type Version struct {
	Major uint32 `protobuf:"varint,1,opt,name=major" json:"major,omitempty"`
	Minor uint32 `protobuf:"varint,2,opt,name=minor" json:"minor,omitempty"`
}

func (m *Version) Reset()                    { *m = Version{} }
func (m *Version) String() string            { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()               {}
func (*Version) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{0} }

func (m *Version) GetMajor() uint32 {
	if m != nil {
		return m.Major
	}
	return 0
}

func (m *Version) GetMinor() uint32 {
	if m != nil {
		return m.Minor
	}
	return 0
}

type Header struct {
	Version  *Version    `protobuf:"bytes,1,opt,name=version" json:"version,omitempty"`
	Type     Header_Type `protobuf:"varint,2,opt,name=type,enum=fort.hermes.Header_Type" json:"type,omitempty"`
	Previous string      `protobuf:"bytes,3,opt,name=previous" json:"previous,omitempty"`
}

func (m *Header) Reset()                    { *m = Header{} }
func (m *Header) String() string            { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()               {}
func (*Header) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{1} }

func (m *Header) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

func (m *Header) GetType() Header_Type {
	if m != nil {
		return m.Type
	}
	return Header_Network
}

func (m *Header) GetPrevious() string {
	if m != nil {
		return m.Previous
	}
	return ""
}

type Footer struct {
	Next string `protobuf:"bytes,1,opt,name=next" json:"next,omitempty"`
}

func (m *Footer) Reset()                    { *m = Footer{} }
func (m *Footer) String() string            { return proto.CompactTextString(m) }
func (*Footer) ProtoMessage()               {}
func (*Footer) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{2} }

func (m *Footer) GetNext() string {
	if m != nil {
		return m.Next
	}
	return ""
}

type FileLine struct {
	Readout *FrameReadout `protobuf:"bytes,1,opt,name=readout" json:"readout,omitempty"`
	Footer  *Footer       `protobuf:"bytes,2,opt,name=footer" json:"footer,omitempty"`
}

func (m *FileLine) Reset()                    { *m = FileLine{} }
func (m *FileLine) String() string            { return proto.CompactTextString(m) }
func (*FileLine) ProtoMessage()               {}
func (*FileLine) Descriptor() ([]byte, []int) { return fileDescriptor2, []int{3} }

func (m *FileLine) GetReadout() *FrameReadout {
	if m != nil {
		return m.Readout
	}
	return nil
}

func (m *FileLine) GetFooter() *Footer {
	if m != nil {
		return m.Footer
	}
	return nil
}

func init() {
	proto.RegisterType((*Version)(nil), "fort.hermes.Version")
	proto.RegisterType((*Header)(nil), "fort.hermes.Header")
	proto.RegisterType((*Footer)(nil), "fort.hermes.Footer")
	proto.RegisterType((*FileLine)(nil), "fort.hermes.FileLine")
	proto.RegisterEnum("fort.hermes.Header_Type", Header_Type_name, Header_Type_value)
}

func init() { proto.RegisterFile("Header.proto", fileDescriptor2) }

var fileDescriptor2 = []byte{
	// 305 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0x91, 0xc1, 0x4e, 0xc2, 0x40,
	0x10, 0x86, 0xad, 0xd4, 0x16, 0xa6, 0x6a, 0xc8, 0xc8, 0xa1, 0x12, 0x4d, 0x48, 0xe3, 0x81, 0x44,
	0x2d, 0x09, 0xc4, 0x17, 0xf0, 0x40, 0x38, 0x18, 0x0f, 0x1b, 0xe3, 0xc1, 0x5b, 0x81, 0x41, 0x56,
	0x68, 0xa7, 0x19, 0x16, 0x94, 0xc7, 0xf1, 0x4d, 0x0d, 0xbb, 0xc5, 0xc0, 0xad, 0x33, 0xfd, 0xfe,
	0x7f, 0xfe, 0x99, 0x85, 0xf3, 0x11, 0x65, 0x53, 0x92, 0xb4, 0x14, 0x36, 0x8c, 0xd1, 0x8c, 0xc5,
	0xa4, 0x73, 0x92, 0x9c, 0x56, 0x6d, 0x1c, 0x4a, 0x96, 0x93, 0xa2, 0x6c, 0xca, 0x6b, 0xe3, 0x80,
	0xe4, 0x09, 0xc2, 0x77, 0x92, 0x95, 0xe6, 0x02, 0x5b, 0x70, 0x96, 0x67, 0x5f, 0x2c, 0xb1, 0xd7,
	0xf1, 0xba, 0x17, 0xca, 0x15, 0xb6, 0xab, 0x0b, 0x96, 0xf8, 0xb4, 0xea, 0xee, 0x8a, 0xe4, 0xd7,
	0x83, 0xc0, 0x0d, 0xc2, 0x14, 0xc2, 0x8d, 0x73, 0xb0, 0xc2, 0xa8, 0xdf, 0x4a, 0x0f, 0x86, 0xa6,
	0x95, 0xbb, 0xda, 0x43, 0xf8, 0x00, 0xbe, 0xd9, 0x96, 0x64, 0xfd, 0x2e, 0xfb, 0xf1, 0x11, 0x5c,
	0x65, 0x7f, 0xdb, 0x96, 0xa4, 0x2c, 0x85, 0x6d, 0xa8, 0x97, 0x42, 0x1b, 0xcd, 0xeb, 0x55, 0x5c,
	0xeb, 0x78, 0xdd, 0x86, 0xfa, 0xaf, 0x93, 0x5b, 0xf0, 0x77, 0x24, 0x46, 0x10, 0xbe, 0x92, 0xf9,
	0x66, 0x59, 0x34, 0x4f, 0xb0, 0x0e, 0xfe, 0x50, 0x2f, 0xa9, 0xe9, 0x25, 0x37, 0x10, 0x0c, 0x99,
	0x0d, 0x09, 0x22, 0xf8, 0x05, 0xfd, 0x18, 0x9b, 0xaf, 0xa1, 0xec, 0x77, 0xb2, 0x84, 0xfa, 0x8e,
	0x7b, 0xd1, 0x05, 0xe1, 0x00, 0x42, 0x71, 0x57, 0xa9, 0x56, 0xb8, 0x3e, 0x4a, 0x75, 0x78, 0x36,
	0xb5, 0x27, 0xf1, 0x1e, 0x82, 0x99, 0xb5, 0xb7, 0x9b, 0x44, 0xfd, 0xab, 0x63, 0x8d, 0xfd, 0xa5,
	0x2a, 0xe4, 0xb9, 0x3b, 0xaa, 0x7d, 0xdc, 0x7d, 0x6a, 0x33, 0x5f, 0x8f, 0xd3, 0x09, 0xe7, 0xbd,
	0x19, 0x4b, 0xae, 0x27, 0x7a, 0x9a, 0xd1, 0xa3, 0x91, 0x6c, 0xb2, 0x20, 0xe9, 0x39, 0xe1, 0x38,
	0xb0, 0xef, 0x32, 0xf8, 0x0b, 0x00, 0x00, 0xff, 0xff, 0xa0, 0xfa, 0xd3, 0x0a, 0xc8, 0x01, 0x00,
	0x00,
}
